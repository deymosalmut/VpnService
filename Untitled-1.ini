Отлично. **Начинаем ЭТАП 3**.
Дальше действуем **строго инженерно**, без преждевременных команд `wg`, `iptables` и «магии».
Сначала — **архитектура и каркас**, потом — реализация.

---

# ЭТАП 3 — Linux Adapter + WireGuard

## Фаза 3.1 — Архитектурное подключение к ОС (БЕЗ WireGuard)

> Цель фазы:
> **расширить ЭТАП 2**, не ломая его, и подготовить точку, куда позже «встанет» WireGuard.

---

## КЛЮЧЕВОЙ ПРИНЦИП ЭТАПА 3

**Control Plane (ЭТАП 2) НЕ МЕНЯЕТСЯ.**

Мы:

* ❌ не трогаем Domain
* ❌ не трогаем Application
* ❌ не добавляем `wg`, `ip`, `iptables` напрямую

Мы:

* ✅ добавляем **Linux Adapter слой**
* ✅ подключаем его через **интерфейсы**
* ✅ соблюдаем Dependency Inversion

---

## 1. НОВАЯ АРХИТЕКТУРНАЯ СХЕМА

```
┌──────────────────────────────┐
│          API (ASP.NET)       │
└──────────────▲───────────────┘
               │
┌──────────────┴───────────────┐
│        Application Layer     │
│  (UseCases / Services)       │
└──────────────▲───────────────┘
               │
┌──────────────┴───────────────┐
│          Domain Layer        │
│  (Entities, Rules)           │
└──────────────▲───────────────┘
               │  interface
┌──────────────┴───────────────┐
│   Infrastructure.Abstractions│  ← НОВОЕ
│   (OS / VPN contracts)       │
└──────────────▲───────────────┘
               │
┌──────────────┴───────────────┐
│ Infrastructure.Linux         │  ← НОВОЕ
│ (реализация под Ubuntu)      │
└──────────────────────────────┘
```

---

## 2. ЧТО МЫ ДЕЛАЕМ В ФАЗЕ 3.1 (СЕЙЧАС)

### Создаём **контракты**, но не реализацию WireGuard

### Новый проект:

```
VpnService.Infrastructure.Abstractions
```

---

## 3. СОЗДАНИЕ ПРОЕКТА (КОМАНДЫ)

В корне решения:

```bash
dotnet new classlib -n VpnService.Infrastructure.Abstractions
```

Добавляем в solution:

```bash
dotnet sln add VpnService.Infrastructure.Abstractions
```

---

## 4. БАЗОВЫЕ ИНТЕРФЕЙСЫ (КЛЮЧЕВЫЕ)

### 4.1 Контракт управления VPN-пирами

`IVpnPeerProvisioner.cs`

```csharp
namespace VpnService.Infrastructure.Abstractions;

public interface IVpnPeerProvisioner
{
    Task ProvisionAsync(
        Guid peerId,
        string publicKey,
        string assignedIp,
        CancellationToken ct);

    Task RevokeAsync(
        Guid peerId,
        CancellationToken ct);
}
```

**Важно:**

* НЕТ WireGuard
* НЕТ Linux
* Это **чистый контракт**

---

### 4.2 Контракт управления VPN-интерфейсом

`IVpnInterfaceManager.cs`

```csharp
namespace VpnService.Infrastructure.Abstractions;

public interface IVpnInterfaceManager
{
    Task EnsureInterfaceExistsAsync(CancellationToken ct);
    Task ReloadConfigurationAsync(CancellationToken ct);
}
```

---

## 5. ПОДКЛЮЧЕНИЕ К APPLICATION (ТОЛЬКО ЧЕРЕЗ DI)

### Пример (Application Service)

```csharp
public class PeerLifecycleService
{
    private readonly IVpnPeerProvisioner _provisioner;

    public PeerLifecycleService(IVpnPeerProvisioner provisioner)
    {
        _provisioner = provisioner;
    }

    public async Task ActivatePeerAsync(Peer peer, CancellationToken ct)
    {
        await _provisioner.ProvisionAsync(
            peer.Id,
            peer.PublicKey,
            peer.AssignedIp,
            ct);
    }
}
```

> ⚠️ ВАЖНО:
> На этом этапе **ничего не будет работать**, и это **нормально**.

---

## 6. ЧТО МЫ ПОКА НЕ ДЕЛАЕМ

Запрещено до следующего шага:

* `wg`
* `wg-quick`
* `/etc/wireguard`
* `iptables`
* `ip link`
* `netlink`
* `sudo` в коде

---

## 7. КОНТРОЛЬНАЯ ПРОВЕРКА ФАЗЫ 3.1

После добавления:

```bash
dotnet build
```

И проверка:

```bash
grep -R "wireguard\|wg \|iptables\|/etc/wireguard" .
```

**Ожидаемо:** пусто.

---

## СТАТУС ПОСЛЕ ЭТОГО ШАГА

Ты будешь в состоянии:

* ✅ Архитектура расширена корректно
* ✅ Control Plane не нарушен
* ✅ Есть точка интеграции с Linux
* ❌ WireGuard ещё не реализован (и это правильно)

---

## ДАЛЬШЕ (СЛЕДУЮЩИЙ ШАГ)

Следующий шаг — **ФАЗА 3.2**:

**Infrastructure.Linux**

* реальный вызов `wg`
* реальный `/etc/wireguard/wg0.conf`
* systemd
* iptables

Но **только после фиксации 3.1**.

---

### ТВОЁ ДЕЙСТВИЕ СЕЙЧАС

Сделай **ФАЗУ 3.1**:

1. Создай `Infrastructure.Abstractions`
2. Добавь интерфейсы
3. Убедись, что проект собирается

После этого напиши:

> `ФАЗА 3.1 ГОТОВА`

И мы **переходим к реальному WireGuard**.
